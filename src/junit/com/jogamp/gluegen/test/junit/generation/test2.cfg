Package com.jogamp.gluegen.test.junit.generation
JavaClass Bindingtest2
Style InterfaceAndImpl
JavaOutputDir classes
NativeOutputDir native

# Use a ProcAddressTable so we dynamically look up the routines
EmitProcAddressTable true
ProcAddressTableClassName Bindingtest2ProcAddressTable
GetProcAddressTableExpr _table
ProcAddressNameExpr PFN $UPPERCASE({0}) PROC

# Force all of the methods to be emitted using dynamic linking so we
# don't need to link against any emulation library on the desktop or
# depend on the presence of an import library for a particular device
ForceProcAddressGen __ALL__

# Also force the calling conventions of the locally generated function
# pointer typedefs for these routines to MYAPIENTRY
# LocalProcAddressCallingConvention __ALL__ MYAPIENTRY

# Opaque long void*

# Undefined struct forward declaration, implementation secret: 'struct T2_UndefStruct;'
Opaque long T2_UndefStruct*
Ignore T2_UndefStruct

EmitStruct T2_ThreadAffinity
StructPackage T2_ThreadAffinity com.jogamp.gluegen.test.junit.generation

EmitStruct T2_UserData
StructPackage T2_UserData com.jogamp.gluegen.test.junit.generation
ReturnsStringOnly T2_UserData.name

EmitStruct T2_PointerStorage
StructPackage T2_PointerStorage com.jogamp.gluegen.test.junit.generation

EmitStruct T2_InitializeOptions
StructPackage T2_InitializeOptions com.jogamp.gluegen.test.junit.generation
ReturnsStringOnly T2_InitializeOptions.ProductName
ReturnsStringOnly T2_InitializeOptions.ProductVersion

# ReturnedArrayLength T2_InitializeOptions.OverrideThreadAffinity 1
MaxOneElement T2_InitializeOptions.OverrideThreadAffinity

# Begin JavaCallback.
#
# JavaCallback requires `JNI_OnLoad*(..)` and `JVMUtil_GetJNIEnv(..)`
LibraryOnLoad Bindingtest2

# typedef void ( * T2_CallbackFunc01)(size_t id, const char* msg, void* usrParam);
# void MessageCallback01(T2_CallbackFunc01 cbFunc, void* usrParam);
# void InjectMessageCallback01(size_t id, const char* msg);
ArgumentIsString T2_CallbackFunc01 1
ArgumentIsString InjectMessageCallback01 1

# Define a JavaCallback.
#   Set JavaCallback via function `MessageCallback01` if `T2_CallbackFunc01` argument is non-null, otherwise removes the mapped callback and associated resources.
#
#   It uses the function-pointer argument `T2_CallbackFunc01` as the callback function type
#   and marks `T2_CallbackFunc01`s 3rd argument (index 2) as the mandatory user-param.
#
#   This callback has no keys defines, rendering it of global scope!
#
#   Explicit maintenance methods are generated, passing the keys as paramters
#   - `boolean isMessageCallback01Mapped()` queries whether `MessageCallback0` is mapped globally
#   - `T2_CallbackFunc01 getMessageCallback01()` returns the global T2_CallbackFunc01, null if not mapped
#   - `Object getMessageCallback01UserParam()` returns the global `usrParam` object, null if not mapped
#   - `void releaseMessageCallback01()` releases callback data skipping toolkit API. Favor passing `null` callback ref to `MessageCallback01(..)`
JavaCallbackDef  MessageCallback01 T2_CallbackFunc01 2
#
# End JavaCallback

# Begin JavaCallback.
#
# typedef void ( * ALEVENTPROCSOFT)(int eventType, int object, int param, int length, const char *message, void *userParam);
# void alEventCallback(ALEVENTPROCSOFT callback, void *userParam /* identity-key */);
# void alEventCallbackInject(int eventType, int object, int param, const char* msg);
ArgumentIsPascalString ALEVENTPROCSOFT 3 4
ArgumentIsString alEventCallbackInject 3

# Define a JavaCallback (OpenAL AL_SOFT_events)
#   Set JavaCallback via function `alEventCallback` if `ALEVENTPROCSOFT` argument is non-null, otherwise removes the mapped callback and associated resources.
#
#   It uses the function-pointer argument `ALEVENTPROCSOFT` as the callback function type
#   and marks `ALEVENTPROCSOFT`s 6th argument (index 5) as the mandatory user-param.
#
#   This callback has no keys defines, rendering it of global scope!
#   The global key-less scope matches `AL_SOFT_events` semantics.
#
#   Explicit maintenance methods are generated, passing the keys as paramters
#   - `boolean isAlEventCallbackMapped()` queries whether `alEventCallback` is mapped globally
#   - `ALEVENTPROCSOFT getAlEventCallback()` returns the global ALEVENTPROCSOFT, null if not mapped
#   - `Object getAlEventCallbackUserParam()` returns the global `userParam` object, null if not mapped
#   - `void releaseAlEventCallback()` releases callback data skipping toolkit API. Favor passing `null` callback ref to `alEventCallback(..)`
JavaCallbackDef  alEventCallback ALEVENTPROCSOFT 5
JavaCallbackKey  alEventCallback
#
# End JavaCallback

# Begin JavaCallback (OpanAL AL_SOFT_callback_buffer)
#
# // typedef void ( * ALBUFFERCALLBACKTYPESOFT)(int buffer, void *userptr, void *sampledata, int numbytes);
# typedef void ( * ALBUFFERCALLBACKTYPESOFT)(int buffer, void *userptr, int sampledata, int numbytes);
#
# void alBufferCallback0(int buffer /* key */, int format, int freq, ALBUFFERCALLBACKTYPESOFT callback, void *userptr /* identity-key */);
#
# // void alBufferCallback0Inject(int buffer, void *sampledata, int numbytes);
# void alBufferCallback0Inject(int buffer, int sampledata, int numbytes);

# Define a JavaCallback.
#   Set JavaCallback via function `alBufferCallback0` if `ALBUFFERCALLBACKTYPESOFT` argument is non-null, otherwise removes the mapped callback and associated resources.
#
#   It uses the function-pointer argument `ALBUFFERCALLBACKTYPESOFT` as the callback function type
#   and marks `ALBUFFERCALLBACKTYPESOFT`s 2nd argument (index 1) as the mandatory user-param.
#
#   This callback defines one key, `buffer`, index 0 of alBufferCallback0(..) parameter list, limiting it to buffer-name scope!
#   The `buffer` key allows setting one callback per buffer-name, compatible with the `AL_SOFT_callback_buffer` spec.
#
#   Explicit maintenance methods are generated, passing the keys as paramters
#   - `Set<AlBufferCallback0Key> getAlBufferCallback0Keys()` returns set of Key { int buffer }
#   - `boolean isAlBufferCallback0Mapped(AlBufferCallback0Key)` queries whether `alBufferCallback0` is mapped to `buffer`.
#   - `ALBUFFERCALLBACKTYPESOFT getAlBufferCallback0(AlBufferCallback0Key)` returns the `buffer` mapped ALEVENTPROCSOFT, null if not mapped
#   - `Object getAlBufferCallback0UserParam(AlBufferCallback0Key)` returns the `buffer` mapped `userptr` object, null if not mapped
#   - `void releaseAllAlBufferCallback0()` releases all callback data mapped via Key { int buffer } skipping toolkit API. Favor passing `null` callback ref to `alBufferCallback0(..)`
#   - `void releaseAlBufferCallback0(AlBufferCallback0Key)` releases callback data mapped to Key { int buffer } skipping toolkit API. Favor passing `null` callback ref to `alBufferCallback0(..)`
JavaCallbackDef  alBufferCallback0 ALBUFFERCALLBACKTYPESOFT 1
JavaCallbackKey  alBufferCallback0 0
#
# End JavaCallback

# Begin JavaCallback (OpanAL AL_SOFT_callback_buffer, variant 2)
#
# Reuses: ALBUFFERCALLBACKTYPESOFT, see above.
#
# void alBufferCallback1(int buffer /* key */, int format, int freq, ALBUFFERCALLBACKTYPESOFT callback, void *userptr /* identity-key */);
#
# // void alBufferCallback1Inject(int buffer, void *sampledata, int numbytes);
# void alBufferCallback1Inject(int buffer, int sampledata, int numbytes);

# Define a JavaCallback.
#   Set JavaCallback via function `alBufferCallback1` if `ALBUFFERCALLBACKTYPESOFT` argument is non-null, otherwise removes the mapped callback and associated resources.
#
#   It uses the function-pointer argument `ALBUFFERCALLBACKTYPESOFT` as the callback function type
#   and marks `ALBUFFERCALLBACKTYPESOFT`s 2nd argument (index 1) as the mandatory user-param.
#
#   This callback defines one key, `buffer`, index 0 of alBufferCallback1(..) parameter list, limiting it to buffer-name scope!
#   The `buffer` key allows setting one callback per buffer-name, compatible with the `AL_SOFT_callback_buffer` spec.
#
#   Explicit maintenance methods are generated, passing the keys as paramters
#   - `boolean isAlBufferCallback1Mapped(int buffer)` queries whether `alBufferCallback1` is mapped to `buffer`.
#   - `ALBUFFERCALLBACKTYPESOFT getAlBufferCallback1(int buffer)` returns the `buffer` mapped ALEVENTPROCSOFT, null if not mapped
#   - `Object getAlBufferCallback1UserParam(int buffer)` returns the `buffer` mapped `userptr` object, null if not mapped
JavaCallbackDef  alBufferCallback1 ALBUFFERCALLBACKTYPESOFT 1 com.jogamp.gluegen.test.junit.generation.Test4JavaCallback.CustomAlBufferCallback1Key
JavaCallbackKey  alBufferCallback1 0
#
# End JavaCallback

# Begin JavaCallback
#
# typedef void ( * T2_CallbackFunc11)(size_t id, const T2_Callback11UserType* usrParam);
# void MessageCallback11a(size_t id /* key */, T2_CallbackFunc11 cbFunc, const T2_Callback11UserType* usrParam);
# void MessageCallback11aInject(size_t id);
#JavaCallbackDef  MessageCallback11a T2_CallbackFunc11 1 com.jogamp.gluegen.test.junit.generation.Test4JavaCallback.CustomMessageCallback11Key
JavaCallbackDef  MessageCallback11a T2_CallbackFunc11 1
JavaCallbackKey  MessageCallback11a 0
#
# End JavaCallback

# void MessageCallback11b(size_t id /* key */, T2_CallbackFunc11 cbFunc, void* Data);
# void MessageCallback11bInject(size_t id);
JavaCallbackDef  MessageCallback11b 2 T2_CallbackFunc11 1
JavaCallbackKey  MessageCallback11b 0

CustomCCode #include "test2.h"

Import com.jogamp.gluegen.test.junit.generation.Bindingtest2
Import com.jogamp.gluegen.test.junit.generation.T2_PointerStorage
Import com.jogamp.gluegen.test.junit.generation.T2_InitializeOptions
Import com.jogamp.gluegen.test.junit.generation.T2_ThreadAffinity
Import com.jogamp.gluegen.test.junit.generation.T2_UserData
Import com.jogamp.gluegen.test.junit.generation.T2_Callback11UserType

CustomJavaCode Bindingtest2Impl  private static Bindingtest2ProcAddressTable _table = new Bindingtest2ProcAddressTable();
CustomJavaCode Bindingtest2Impl  public static void resetProcAddressTable(DynamicLookupHelper lookup) {
CustomJavaCode Bindingtest2Impl      _table.reset(lookup);
CustomJavaCode Bindingtest2Impl  }

